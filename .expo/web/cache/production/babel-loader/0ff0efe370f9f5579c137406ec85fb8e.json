{"ast":null,"code":"import*as React from'react';import{getStateFromPath as getStateFromPathDefault,getPathFromState as getPathFromStateDefault,getActionFromState}from'@react-navigation/core';var getStateLength=function getStateLength(state){var length=0;if(state.history){length=state.history.length;}else{length=state.index+1;}var focusedState=state.routes[state.index].state;if(focusedState&&!focusedState.stale){length+=getStateLength(focusedState)-1;}return length;};var isUsingLinking=false;export default function useLinking(ref,_ref){var _ref$enabled=_ref.enabled,enabled=_ref$enabled===void 0?true:_ref$enabled,config=_ref.config,_ref$getStateFromPath=_ref.getStateFromPath,getStateFromPath=_ref$getStateFromPath===void 0?getStateFromPathDefault:_ref$getStateFromPath,_ref$getPathFromState=_ref.getPathFromState,getPathFromState=_ref$getPathFromState===void 0?getPathFromStateDefault:_ref$getPathFromState;React.useEffect(function(){if(enabled!==false&&isUsingLinking){throw new Error(['Looks like you have configured linking in multiple places. This is likely an error since URL integration should only be handled in one place to avoid conflicts. Make sure that:',\"- You are not using both 'linking' prop and 'useLinking'\",\"- You don't have 'useLinking' in multiple components\"].join('\\n').trim());}else{isUsingLinking=enabled!==false;}return function(){isUsingLinking=false;};});var enabledRef=React.useRef(enabled);var configRef=React.useRef(config);var getStateFromPathRef=React.useRef(getStateFromPath);var getPathFromStateRef=React.useRef(getPathFromState);React.useEffect(function(){enabledRef.current=enabled;configRef.current=config;getStateFromPathRef.current=getStateFromPath;getPathFromStateRef.current=getPathFromState;},[config,enabled,getPathFromState,getStateFromPath]);var getInitialState=React.useCallback(function(){var value;if(enabledRef.current){var path=location.pathname+location.search;if(path){value=getStateFromPathRef.current(path,configRef.current);}}var thenable={then:function then(onfulfilled){return Promise.resolve(onfulfilled?onfulfilled(value):value);},catch:function _catch(){return thenable;}};return thenable;},[]);var previousStateLengthRef=React.useRef(undefined);var previousHistoryIndexRef=React.useRef(0);var pendingIndexChangeRef=React.useRef();var pendingStateUpdateRef=React.useRef(false);var pendingStateMultiUpdateRef=React.useRef(false);var numberOfIndicesAhead=React.useRef(0);React.useEffect(function(){var onPopState=function onPopState(){var _history$state$index,_history$state;var navigation=ref.current;if(!navigation||!enabled){return;}var previousHistoryIndex=previousHistoryIndexRef.current;var historyIndex=(_history$state$index=(_history$state=history.state)===null||_history$state===void 0?void 0:_history$state.index)!==null&&_history$state$index!==void 0?_history$state$index:0;previousHistoryIndexRef.current=historyIndex;if(pendingIndexChangeRef.current===historyIndex){pendingIndexChangeRef.current=undefined;return;}var state=navigation.getRootState();var path=getPathFromStateRef.current(state,configRef.current);var canGoBack=true;var numberOfBacks=0;if(previousHistoryIndex===historyIndex){if(location.pathname+location.search!==path){pendingStateUpdateRef.current=true;history.replaceState({index:historyIndex},'',path);}}else if(previousHistoryIndex>historyIndex){numberOfBacks=previousHistoryIndex-historyIndex-numberOfIndicesAhead.current;if(numberOfBacks>0){pendingStateMultiUpdateRef.current=true;if(numberOfBacks>1){pendingStateMultiUpdateRef.current=true;}pendingStateUpdateRef.current=true;for(var i=0;i<numberOfBacks;i++){navigation.goBack();}}else{canGoBack=false;}}if(previousHistoryIndex<historyIndex||!canGoBack){if(canGoBack){numberOfIndicesAhead.current=historyIndex-previousHistoryIndex-1;}else{navigation.goBack();numberOfIndicesAhead.current-=previousHistoryIndex-historyIndex;}var _state=getStateFromPathRef.current(location.pathname+location.search,configRef.current);pendingStateMultiUpdateRef.current=true;if(_state){var action=getActionFromState(_state);pendingStateUpdateRef.current=true;if(action!==undefined){navigation.dispatch(action);}else{navigation.resetRoot(_state);}}}};window.addEventListener('popstate',onPopState);return function(){return window.removeEventListener('popstate',onPopState);};},[enabled,ref]);React.useEffect(function(){var _ref$current;if(!enabled){return;}if(ref.current&&previousStateLengthRef.current===undefined){previousStateLengthRef.current=getStateLength(ref.current.getRootState());}if(ref.current&&location.pathname+location.search==='/'){var _history$state$index2,_history$state2;history.replaceState({index:(_history$state$index2=(_history$state2=history.state)===null||_history$state2===void 0?void 0:_history$state2.index)!==null&&_history$state$index2!==void 0?_history$state$index2:0},'',getPathFromStateRef.current(ref.current.getRootState(),configRef.current));}var unsubscribe=(_ref$current=ref.current)===null||_ref$current===void 0?void 0:_ref$current.addListener('state',function(){var _previousStateLengthR,_history$state$index3,_history$state3;var navigation=ref.current;if(!navigation){return;}var state=navigation.getRootState();var path=getPathFromStateRef.current(state,configRef.current);var previousStateLength=(_previousStateLengthR=previousStateLengthRef.current)!==null&&_previousStateLengthR!==void 0?_previousStateLengthR:1;var stateLength=getStateLength(state);if(pendingStateMultiUpdateRef.current){if(location.pathname+location.search===path){pendingStateMultiUpdateRef.current=false;}else{return;}}previousStateLengthRef.current=stateLength;if(pendingStateUpdateRef.current&&location.pathname+location.search===path){pendingStateUpdateRef.current=false;return;}var index=(_history$state$index3=(_history$state3=history.state)===null||_history$state3===void 0?void 0:_history$state3.index)!==null&&_history$state$index3!==void 0?_history$state$index3:0;if(previousStateLength===stateLength){if(location.pathname+location.search!==path){history.replaceState({index:index},'',path);previousHistoryIndexRef.current=index;}}else if(stateLength>previousStateLength){for(var i=0,l=stateLength-previousStateLength;i<l;i++){index++;history.pushState({index:index},'',path);}previousHistoryIndexRef.current=index;}else if(previousStateLength>stateLength){var delta=Math.min(previousStateLength-stateLength,previousHistoryIndexRef.current-1);if(delta>0){pendingIndexChangeRef.current=index-delta;history.go(-delta);}else{if(location.pathname+location.search!==path){history.replaceState({index:index},'',path);previousHistoryIndexRef.current=index;}}}});return unsubscribe;});return{getInitialState:getInitialState};}","map":{"version":3,"sources":["useLinking.tsx"],"names":["getStateFromPath","getPathFromState","getStateLength","state","length","focusedState","isUsingLinking","enabled","getPathFromStateDefault","React","enabledRef","configRef","getStateFromPathRef","getPathFromStateRef","getInitialState","path","location","value","thenable","then","Promise","onfulfilled","catch","previousStateLengthRef","previousHistoryIndexRef","pendingIndexChangeRef","pendingStateUpdateRef","pendingStateMultiUpdateRef","numberOfIndicesAhead","onPopState","navigation","ref","previousHistoryIndex","historyIndex","history","canGoBack","numberOfBacks","index","i","action","getActionFromState","window","unsubscribe","previousStateLength","stateLength","l","delta","Math"],"mappings":"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","sourcesContent":["import * as React from 'react';\nimport {\n  getStateFromPath as getStateFromPathDefault,\n  getPathFromState as getPathFromStateDefault,\n  NavigationContainerRef,\n  NavigationState,\n  getActionFromState,\n} from '@react-navigation/core';\nimport { LinkingOptions } from './types';\n\ntype ResultState = ReturnType<typeof getStateFromPathDefault>;\n\ntype HistoryState = { index: number };\n\ndeclare const history: {\n  state?: HistoryState;\n  go(delta: number): void;\n  pushState(state: HistoryState, title: string, url: string): void;\n  replaceState(state: HistoryState, title: string, url: string): void;\n};\n\nconst getStateLength = (state: NavigationState) => {\n  let length = 0;\n\n  if (state.history) {\n    length = state.history.length;\n  } else {\n    length = state.index + 1;\n  }\n\n  const focusedState = state.routes[state.index].state;\n\n  if (focusedState && !focusedState.stale) {\n    // If the focused route has history entries, we need to count them as well\n    length += getStateLength(focusedState as NavigationState) - 1;\n  }\n\n  return length;\n};\n\nlet isUsingLinking = false;\n\nexport default function useLinking(\n  ref: React.RefObject<NavigationContainerRef>,\n  {\n    enabled = true,\n    config,\n    getStateFromPath = getStateFromPathDefault,\n    getPathFromState = getPathFromStateDefault,\n  }: LinkingOptions\n) {\n  React.useEffect(() => {\n    if (enabled !== false && isUsingLinking) {\n      throw new Error(\n        [\n          'Looks like you have configured linking in multiple places. This is likely an error since URL integration should only be handled in one place to avoid conflicts. Make sure that:',\n          \"- You are not using both 'linking' prop and 'useLinking'\",\n          \"- You don't have 'useLinking' in multiple components\",\n        ]\n          .join('\\n')\n          .trim()\n      );\n    } else {\n      isUsingLinking = enabled !== false;\n    }\n\n    return () => {\n      isUsingLinking = false;\n    };\n  });\n\n  // We store these options in ref to avoid re-creating getInitialState and re-subscribing listeners\n  // This lets user avoid wrapping the items in `React.useCallback` or `React.useMemo`\n  // Not re-creating `getInitialState` is important coz it makes it easier for the user to use in an effect\n  const enabledRef = React.useRef(enabled);\n  const configRef = React.useRef(config);\n  const getStateFromPathRef = React.useRef(getStateFromPath);\n  const getPathFromStateRef = React.useRef(getPathFromState);\n\n  React.useEffect(() => {\n    enabledRef.current = enabled;\n    configRef.current = config;\n    getStateFromPathRef.current = getStateFromPath;\n    getPathFromStateRef.current = getPathFromState;\n  }, [config, enabled, getPathFromState, getStateFromPath]);\n\n  const getInitialState = React.useCallback(() => {\n    let value: ResultState | undefined;\n\n    if (enabledRef.current) {\n      const path = location.pathname + location.search;\n\n      if (path) {\n        value = getStateFromPathRef.current(path, configRef.current);\n      }\n    }\n\n    // Make it a thenable to keep consistent with the native impl\n    const thenable = {\n      then(onfulfilled?: (state: ResultState | undefined) => void) {\n        return Promise.resolve(onfulfilled ? onfulfilled(value) : value);\n      },\n      catch() {\n        return thenable;\n      },\n    };\n\n    return thenable as PromiseLike<ResultState | undefined>;\n  }, []);\n\n  const previousStateLengthRef = React.useRef<number | undefined>(undefined);\n  const previousHistoryIndexRef = React.useRef(0);\n\n  const pendingIndexChangeRef = React.useRef<number | undefined>();\n  const pendingStateUpdateRef = React.useRef<boolean>(false);\n  const pendingStateMultiUpdateRef = React.useRef<boolean>(false);\n\n  // If we're navigating ahead >1, we're not restoring whole state,\n  // but just navigate to the selected route not caring about previous routes\n  // therefore if we need to go back, we need to pop screen and navigate to the new one\n  // Possibly, we will need to reuse the same mechanism.\n  // E.g. if we went ahead+4 (numberOfIndicesAhead = 3), and back-2,\n  // actually we need to pop the screen we navigated\n  // and navigate again, setting numberOfIndicesAhead to 1.\n  const numberOfIndicesAhead = React.useRef(0);\n\n  React.useEffect(() => {\n    const onPopState = () => {\n      const navigation = ref.current;\n\n      if (!navigation || !enabled) {\n        return;\n      }\n\n      const previousHistoryIndex = previousHistoryIndexRef.current;\n      const historyIndex = history.state?.index ?? 0;\n\n      previousHistoryIndexRef.current = historyIndex;\n\n      if (pendingIndexChangeRef.current === historyIndex) {\n        pendingIndexChangeRef.current = undefined;\n        return;\n      }\n\n      const state = navigation.getRootState();\n      const path = getPathFromStateRef.current(state, configRef.current);\n\n      let canGoBack = true;\n      let numberOfBacks = 0;\n\n      if (previousHistoryIndex === historyIndex) {\n        if (location.pathname + location.search !== path) {\n          pendingStateUpdateRef.current = true;\n          history.replaceState({ index: historyIndex }, '', path);\n        }\n      } else if (previousHistoryIndex > historyIndex) {\n        numberOfBacks =\n          previousHistoryIndex - historyIndex - numberOfIndicesAhead.current;\n\n        if (numberOfBacks > 0) {\n          pendingStateMultiUpdateRef.current = true;\n\n          if (numberOfBacks > 1) {\n            pendingStateMultiUpdateRef.current = true;\n          }\n\n          pendingStateUpdateRef.current = true;\n\n          for (let i = 0; i < numberOfBacks; i++) {\n            navigation.goBack();\n          }\n        } else {\n          canGoBack = false;\n        }\n      }\n\n      if (previousHistoryIndex < historyIndex || !canGoBack) {\n        if (canGoBack) {\n          numberOfIndicesAhead.current =\n            historyIndex - previousHistoryIndex - 1;\n        } else {\n          navigation.goBack();\n          numberOfIndicesAhead.current -= previousHistoryIndex - historyIndex;\n        }\n\n        const state = getStateFromPathRef.current(\n          location.pathname + location.search,\n          configRef.current\n        );\n\n        pendingStateMultiUpdateRef.current = true;\n\n        if (state) {\n          const action = getActionFromState(state);\n\n          pendingStateUpdateRef.current = true;\n\n          if (action !== undefined) {\n            navigation.dispatch(action);\n          } else {\n            navigation.resetRoot(state);\n          }\n        }\n      }\n    };\n\n    window.addEventListener('popstate', onPopState);\n\n    return () => window.removeEventListener('popstate', onPopState);\n  }, [enabled, ref]);\n\n  React.useEffect(() => {\n    if (!enabled) {\n      return;\n    }\n\n    if (ref.current && previousStateLengthRef.current === undefined) {\n      previousStateLengthRef.current = getStateLength(\n        ref.current.getRootState()\n      );\n    }\n\n    if (ref.current && location.pathname + location.search === '/') {\n      history.replaceState(\n        { index: history.state?.index ?? 0 },\n        '',\n        getPathFromStateRef.current(\n          ref.current.getRootState(),\n          configRef.current\n        )\n      );\n    }\n\n    const unsubscribe = ref.current?.addListener('state', () => {\n      const navigation = ref.current;\n\n      if (!navigation) {\n        return;\n      }\n\n      const state = navigation.getRootState();\n      const path = getPathFromStateRef.current(state, configRef.current);\n\n      const previousStateLength = previousStateLengthRef.current ?? 1;\n      const stateLength = getStateLength(state);\n\n      if (pendingStateMultiUpdateRef.current) {\n        if (location.pathname + location.search === path) {\n          pendingStateMultiUpdateRef.current = false;\n        } else {\n          return;\n        }\n      }\n\n      previousStateLengthRef.current = stateLength;\n\n      if (\n        pendingStateUpdateRef.current &&\n        location.pathname + location.search === path\n      ) {\n        pendingStateUpdateRef.current = false;\n        return;\n      }\n\n      let index = history.state?.index ?? 0;\n\n      if (previousStateLength === stateLength) {\n        // If no new entries were added to history in our navigation state, we want to replaceState\n        if (location.pathname + location.search !== path) {\n          history.replaceState({ index }, '', path);\n          previousHistoryIndexRef.current = index;\n        }\n      } else if (stateLength > previousStateLength) {\n        // If new entries were added, pushState until we have same length\n        // This won't be accurate if multiple entries were added at once, but that's the best we can do\n        for (let i = 0, l = stateLength - previousStateLength; i < l; i++) {\n          index++;\n          history.pushState({ index }, '', path);\n        }\n\n        previousHistoryIndexRef.current = index;\n      } else if (previousStateLength > stateLength) {\n        const delta = Math.min(\n          previousStateLength - stateLength,\n          // We need to keep at least one item in the history\n          // Otherwise we'll exit the page\n          previousHistoryIndexRef.current - 1\n        );\n\n        if (delta > 0) {\n          // We need to set this to ignore the `popstate` event\n          pendingIndexChangeRef.current = index - delta;\n\n          // If new entries were removed, go back so that we have same length\n          history.go(-delta);\n        } else {\n          // We're not going back in history, but the navigation state changed\n          // The URL probably also changed, so we need to re-sync the URL\n          if (location.pathname + location.search !== path) {\n            history.replaceState({ index }, '', path);\n            previousHistoryIndexRef.current = index;\n          }\n        }\n      }\n    });\n\n    return unsubscribe;\n  });\n\n  return {\n    getInitialState,\n  };\n}\n"]},"metadata":{},"sourceType":"module"}