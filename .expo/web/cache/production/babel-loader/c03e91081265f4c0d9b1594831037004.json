{"ast":null,"code":"import _toConsumableArray from\"@babel/runtime/helpers/toConsumableArray\";function _createForOfIteratorHelperLoose(o){var i=0;if(typeof Symbol===\"undefined\"||o[typeof Symbol===\"function\"?Symbol.iterator:\"@@iterator\"]==null){if(Array.isArray(o)||(o=_unsupportedIterableToArray(o)))return function(){if(i>=o.length)return{done:true};return{done:false,value:o[i++]};};throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");}i=o[typeof Symbol===\"function\"?Symbol.iterator:\"@@iterator\"]();return i.next.bind(i);}function _unsupportedIterableToArray(o,minLen){if(!o)return;if(typeof o===\"string\")return _arrayLikeToArray(o,minLen);var n=Object.prototype.toString.call(o).slice(8,-1);if(n===\"Object\"&&o.constructor)n=o.constructor.name;if(n===\"Map\"||n===\"Set\")return Array.from(o);if(n===\"Arguments\"||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))return _arrayLikeToArray(o,minLen);}function _arrayLikeToArray(arr,len){if(len==null||len>arr.length)len=arr.length;for(var i=0,arr2=new Array(len);i<len;i++){arr2[i]=arr[i];}return arr2;}function ownKeys(object,enumerableOnly){var keys=Object.keys(object);if(Object.getOwnPropertySymbols){var symbols=Object.getOwnPropertySymbols(object);if(enumerableOnly)symbols=symbols.filter(function(sym){return Object.getOwnPropertyDescriptor(object,sym).enumerable;});keys.push.apply(keys,symbols);}return keys;}function _objectSpread(target){for(var i=1;i<arguments.length;i++){var source=arguments[i]!=null?arguments[i]:{};if(i%2){ownKeys(Object(source),true).forEach(function(key){_defineProperty(target,key,source[key]);});}else if(Object.getOwnPropertyDescriptors){Object.defineProperties(target,Object.getOwnPropertyDescriptors(source));}else{ownKeys(Object(source)).forEach(function(key){Object.defineProperty(target,key,Object.getOwnPropertyDescriptor(source,key));});}}return target;}function _defineProperty(obj,key,value){if(key in obj){Object.defineProperty(obj,key,{value:value,enumerable:true,configurable:true,writable:true});}else{obj[key]=value;}return obj;}import escape from'escape-string-regexp';import queryString from'query-string';export default function getStateFromPath(path){var _ref;var options=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};var initialRoutes=[];var configs=(_ref=[]).concat.apply(_ref,_toConsumableArray(Object.keys(options).map(function(key){return createNormalizedConfigs(key,options,[],initialRoutes);})));configs.sort(function(config1,config2){return config2.pattern.split('/').length-config1.pattern.split('/').length;});var remaining=path.replace(/\\/+/g,'/').replace(/^\\//,'').replace(/\\?.*$/,'');remaining=remaining.endsWith('/')?remaining:\"\".concat(remaining,\"/\");if(remaining==='/'){var match=configs.find(function(config){return config.pattern===''&&config.routeNames.every(function(name){var _configs$find;return!((_configs$find=configs.find(function(c){return c.screen===name;}))===null||_configs$find===void 0?void 0:_configs$find.pattern);});});if(match){return createNestedStateObject(match.routeNames,initialRoutes,parseQueryParams(path,match.parse));}return undefined;}var result;var current;while(remaining){var routeNames=void 0;var _params=void 0;var _loop2=function _loop2(config){if(!config.match){return\"continue\";}var match=remaining.match(config.match);if(match){routeNames=_toConsumableArray(config.routeNames);var paramPatterns=config.pattern.split('/').filter(function(p){return p.startsWith(':');});if(paramPatterns.length){_params=paramPatterns.reduce(function(acc,p,i){var key=p.replace(/^:/,'').replace(/\\?$/,'');var value=match[(i+1)*2].replace(/\\//,'');if(value){acc[key]=config.parse&&config.parse[key]?config.parse[key](value):value;}return acc;},{});}remaining=remaining.replace(match[1],'');return\"break\";}};_loop:for(var _iterator=_createForOfIteratorHelperLoose(configs),_step;!(_step=_iterator()).done;){var config=_step.value;var _ret=_loop2(config);switch(_ret){case\"continue\":continue;case\"break\":break _loop;}}if(routeNames===undefined){var segments=remaining.split('/');routeNames=[decodeURIComponent(segments[0])];segments.shift();remaining=segments.join('/');}var state=createNestedStateObject(routeNames,initialRoutes,_params);if(current){var _current2;while((_current=current)===null||_current===void 0?void 0:_current.routes[current.index||0].state){var _current;current=current.routes[current.index||0].state;}current.routes[((_current2=current)===null||_current2===void 0?void 0:_current2.index)||0].state=state;}else{result=state;}current=state;}if(current==null||result==null){return undefined;}var route=findFocusedRoute(current);var params=parseQueryParams(path,findParseConfigForRoute(route.name,configs));if(params){route.params=_objectSpread(_objectSpread({},route.params),params);}return result;}function createNormalizedConfigs(key,routeConfig){var routeNames=arguments.length>2&&arguments[2]!==undefined?arguments[2]:[];var initials=arguments.length>3?arguments[3]:undefined;var configs=[];routeNames.push(key);var value=routeConfig[key];if(typeof value==='string'){configs.push(createConfigItem(key,routeNames,value));}else if(typeof value==='object'){if(typeof value.path==='string'){configs.push(createConfigItem(key,routeNames,value.path,value.parse));}if(value.screens){if(value.initialRouteName){initials.push({initialRouteName:value.initialRouteName,connectedRoutes:Object.keys(value.screens)});}Object.keys(value.screens).forEach(function(nestedConfig){var result=createNormalizedConfigs(nestedConfig,value.screens,routeNames,initials);configs.push.apply(configs,_toConsumableArray(result));});}}routeNames.pop();return configs;}function createConfigItem(screen,routeNames,pattern,parse){var match=pattern?new RegExp(\"^(\".concat(pattern.split('/').map(function(it){if(it.startsWith(':')){return\"(([^/]+\\\\/)\".concat(it.endsWith('?')?'?':'',\")\");}return\"\".concat(escape(it),\"\\\\/\");}).join(''),\")\")):null;return{screen:screen,match:match,pattern:pattern,routeNames:_toConsumableArray(routeNames),parse:parse};}function findParseConfigForRoute(routeName,flatConfig){for(var _iterator2=_createForOfIteratorHelperLoose(flatConfig),_step2;!(_step2=_iterator2()).done;){var config=_step2.value;if(routeName===config.routeNames[config.routeNames.length-1]){return config.parse;}}return undefined;}function findInitialRoute(routeName,initialRoutes){for(var _iterator3=_createForOfIteratorHelperLoose(initialRoutes),_step3;!(_step3=_iterator3()).done;){var config=_step3.value;if(config.connectedRoutes.includes(routeName)){return config.initialRouteName===routeName?undefined:config.initialRouteName;}}return undefined;}function createStateObject(initialRoute,routeName,isEmpty,params){if(isEmpty){if(initialRoute){return{index:1,routes:[{name:initialRoute},_objectSpread({name:routeName},params&&{params:params})]};}else{return{routes:[_objectSpread({name:routeName},params&&{params:params})]};}}else{if(initialRoute){return{index:1,routes:[{name:initialRoute},{name:routeName,state:{routes:[]}}]};}else{return{routes:[{name:routeName,state:{routes:[]}}]};}}}function createNestedStateObject(routeNames,initialRoutes,params){var state;var routeName=routeNames.shift();var initialRoute=findInitialRoute(routeName,initialRoutes);state=createStateObject(initialRoute,routeName,routeNames.length===0,params);if(routeNames.length>0){var nestedState=state;while(routeName=routeNames.shift()){initialRoute=findInitialRoute(routeName,initialRoutes);nestedState.routes[nestedState.index||0].state=createStateObject(initialRoute,routeName,routeNames.length===0,params);if(routeNames.length>0){nestedState=nestedState.routes[nestedState.index||0].state;}}}return state;}function findFocusedRoute(state){var _current4;var current=state;while((_current3=current)===null||_current3===void 0?void 0:_current3.routes[current.index||0].state){var _current3;current=current.routes[current.index||0].state;}var route=current.routes[((_current4=current)===null||_current4===void 0?void 0:_current4.index)||0];return route;}function parseQueryParams(path,parseConfig){var query=path.split('?')[1];var params=queryString.parse(query);if(parseConfig){Object.keys(params).forEach(function(name){if(parseConfig[name]&&typeof params[name]==='string'){params[name]=parseConfig[name](params[name]);}});}return Object.keys(params).length?params:undefined;}","map":{"version":3,"sources":["getStateFromPath.tsx"],"names":["options","initialRoutes","configs","Object","key","createNormalizedConfigs","config2","config1","remaining","match","config","name","c","createNestedStateObject","parseQueryParams","routeNames","params","paramPatterns","p","value","i","acc","segments","decodeURIComponent","state","current","result","route","findFocusedRoute","findParseConfigForRoute","routeConfig","createConfigItem","initials","initialRouteName","connectedRoutes","nestedConfig","pattern","it","escape","screen","parse","routeName","index","routes","initialRoute","findInitialRoute","createStateObject","nestedState","query","path","queryString","parseConfig"],"mappings":"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","sourcesContent":["import escape from 'escape-string-regexp';\nimport queryString from 'query-string';\nimport {\n  NavigationState,\n  PartialState,\n  InitialState,\n} from '@react-navigation/routers';\n\ntype ParseConfig = Record<string, (value: string) => any>;\n\ntype Options = {\n  [routeName: string]:\n    | string\n    | {\n        path?: string;\n        parse?: ParseConfig;\n        screens?: Options;\n        initialRouteName?: string;\n      };\n};\n\ntype RouteConfig = {\n  screen: string;\n  match: RegExp | null;\n  pattern: string;\n  routeNames: string[];\n  parse: ParseConfig | undefined;\n};\n\ntype InitialRouteConfig = {\n  initialRouteName: string;\n  connectedRoutes: string[];\n};\n\ntype ResultState = PartialState<NavigationState> & {\n  state?: ResultState;\n};\n\n/**\n * Utility to parse a path string to initial state object accepted by the container.\n * This is useful for deep linking when we need to handle the incoming URL.\n *\n * Example:\n * ```js\n * getStateFromPath(\n *   '/chat/jane/42',\n *   {\n *     Chat: {\n *       path: 'chat/:author/:id',\n *       parse: { id: Number }\n *     }\n *   }\n * )\n * ```\n * @param path Path string to parse and convert, e.g. /foo/bar?count=42.\n * @param options Extra options to fine-tune how to parse the path.\n */\nexport default function getStateFromPath(\n  path: string,\n  options: Options = {}\n): ResultState | undefined {\n  let initialRoutes: InitialRouteConfig[] = [];\n\n  // Create a normalized configs array which will be easier to use\n  const configs = ([] as RouteConfig[]).concat(\n    ...Object.keys(options).map((key) =>\n      createNormalizedConfigs(key, options, [], initialRoutes)\n    )\n  );\n\n  // sort configs so the most exhaustive is always first to be chosen\n  configs.sort(\n    (config1, config2) =>\n      config2.pattern.split('/').length - config1.pattern.split('/').length\n  );\n\n  let remaining = path\n    .replace(/\\/+/g, '/') // Replace multiple slash (//) with single ones\n    .replace(/^\\//, '') // Remove extra leading slash\n    .replace(/\\?.*$/, ''); // Remove query params which we will handle later\n\n  // Make sure there is a trailing slash\n  remaining = remaining.endsWith('/') ? remaining : `${remaining}/`;\n\n  if (remaining === '/') {\n    // We need to add special handling of empty path so navigation to empty path also works\n    // When handling empty path, we should only look at the root level config\n    const match = configs.find(\n      (config) =>\n        config.pattern === '' &&\n        config.routeNames.every(\n          // make sure that none of the parent configs have a non-empty path defined\n          (name) => !configs.find((c) => c.screen === name)?.pattern\n        )\n    );\n\n    if (match) {\n      return createNestedStateObject(\n        match.routeNames,\n        initialRoutes,\n        parseQueryParams(path, match.parse)\n      );\n    }\n\n    return undefined;\n  }\n\n  let result: PartialState<NavigationState> | undefined;\n  let current: PartialState<NavigationState> | undefined;\n\n  while (remaining) {\n    let routeNames: string[] | undefined;\n    let params: Record<string, any> | undefined;\n\n    // Go through all configs, and see if the next path segment matches our regex\n    for (const config of configs) {\n      if (!config.match) {\n        continue;\n      }\n\n      const match = remaining.match(config.match);\n\n      // If our regex matches, we need to extract params from the path\n      if (match) {\n        routeNames = [...config.routeNames];\n\n        const paramPatterns = config.pattern\n          .split('/')\n          .filter((p) => p.startsWith(':'));\n\n        if (paramPatterns.length) {\n          params = paramPatterns.reduce<Record<string, any>>((acc, p, i) => {\n            const key = p.replace(/^:/, '').replace(/\\?$/, '');\n            const value = match[(i + 1) * 2].replace(/\\//, ''); // The param segments appear every second item starting from 2 in the regex match result\n\n            if (value) {\n              acc[key] =\n                config.parse && config.parse[key]\n                  ? config.parse[key](value)\n                  : value;\n            }\n\n            return acc;\n          }, {});\n        }\n\n        remaining = remaining.replace(match[1], '');\n\n        break;\n      }\n    }\n\n    // If we hadn't matched any segments earlier, use the path as route name\n    if (routeNames === undefined) {\n      const segments = remaining.split('/');\n\n      routeNames = [decodeURIComponent(segments[0])];\n      segments.shift();\n      remaining = segments.join('/');\n    }\n\n    const state = createNestedStateObject(routeNames, initialRoutes, params);\n\n    if (current) {\n      // The state should be nested inside the deepest route we parsed before\n      while (current?.routes[current.index || 0].state) {\n        current = current.routes[current.index || 0].state;\n      }\n\n      (current as PartialState<NavigationState>).routes[\n        current?.index || 0\n      ].state = state;\n    } else {\n      result = state;\n    }\n\n    current = state;\n  }\n\n  if (current == null || result == null) {\n    return undefined;\n  }\n\n  const route = findFocusedRoute(current);\n  const params = parseQueryParams(\n    path,\n    findParseConfigForRoute(route.name, configs)\n  );\n\n  if (params) {\n    route.params = { ...route.params, ...params };\n  }\n\n  return result;\n}\n\nfunction createNormalizedConfigs(\n  key: string,\n  routeConfig: Options,\n  routeNames: string[] = [],\n  initials: InitialRouteConfig[]\n): RouteConfig[] {\n  const configs: RouteConfig[] = [];\n\n  routeNames.push(key);\n\n  const value = routeConfig[key];\n\n  if (typeof value === 'string') {\n    // If a string is specified as the value of the key(e.g. Foo: '/path'), use it as the pattern\n    configs.push(createConfigItem(key, routeNames, value));\n  } else if (typeof value === 'object') {\n    // if an object is specified as the value (e.g. Foo: { ... }),\n    // it can have `path` property and\n    // it could have `screens` prop which has nested configs\n    if (typeof value.path === 'string') {\n      configs.push(createConfigItem(key, routeNames, value.path, value.parse));\n    }\n\n    if (value.screens) {\n      // property `initialRouteName` without `screens` has no purpose\n      if (value.initialRouteName) {\n        initials.push({\n          initialRouteName: value.initialRouteName,\n          connectedRoutes: Object.keys(value.screens),\n        });\n      }\n      Object.keys(value.screens).forEach((nestedConfig) => {\n        const result = createNormalizedConfigs(\n          nestedConfig,\n          value.screens as Options,\n          routeNames,\n          initials\n        );\n        configs.push(...result);\n      });\n    }\n  }\n\n  routeNames.pop();\n\n  return configs;\n}\n\nfunction createConfigItem(\n  screen: string,\n  routeNames: string[],\n  pattern: string,\n  parse?: ParseConfig\n): RouteConfig {\n  const match = pattern\n    ? new RegExp(\n        `^(${pattern\n          .split('/')\n          .map((it) => {\n            if (it.startsWith(':')) {\n              return `(([^/]+\\\\/)${it.endsWith('?') ? '?' : ''})`;\n            }\n\n            return `${escape(it)}\\\\/`;\n          })\n          .join('')})`\n      )\n    : null;\n\n  return {\n    screen,\n    match,\n    pattern,\n    // The routeNames array is mutated, so copy it to keep the current state\n    routeNames: [...routeNames],\n    parse,\n  };\n}\n\nfunction findParseConfigForRoute(\n  routeName: string,\n  flatConfig: RouteConfig[]\n): ParseConfig | undefined {\n  for (const config of flatConfig) {\n    if (routeName === config.routeNames[config.routeNames.length - 1]) {\n      return config.parse;\n    }\n  }\n  return undefined;\n}\n\n// tries to find an initial route connected with the one passed\nfunction findInitialRoute(\n  routeName: string,\n  initialRoutes: InitialRouteConfig[]\n): string | undefined {\n  for (const config of initialRoutes) {\n    if (config.connectedRoutes.includes(routeName)) {\n      return config.initialRouteName === routeName\n        ? undefined\n        : config.initialRouteName;\n    }\n  }\n  return undefined;\n}\n\n// returns state object with values depending on whether\n// it is the end of state and if there is initialRoute for this level\nfunction createStateObject(\n  initialRoute: string | undefined,\n  routeName: string,\n  isEmpty: boolean,\n  params?: Record<string, any> | undefined\n): InitialState {\n  if (isEmpty) {\n    if (initialRoute) {\n      return {\n        index: 1,\n        routes: [\n          { name: initialRoute },\n          { name: routeName as string, ...(params && { params }) },\n        ],\n      };\n    } else {\n      return {\n        routes: [{ name: routeName as string, ...(params && { params }) }],\n      };\n    }\n  } else {\n    if (initialRoute) {\n      return {\n        index: 1,\n        routes: [\n          { name: initialRoute },\n          { name: routeName as string, state: { routes: [] } },\n        ],\n      };\n    } else {\n      return { routes: [{ name: routeName as string, state: { routes: [] } }] };\n    }\n  }\n}\n\nfunction createNestedStateObject(\n  routeNames: string[],\n  initialRoutes: InitialRouteConfig[],\n  params: object | undefined\n) {\n  let state: InitialState;\n  let routeName = routeNames.shift() as string;\n  let initialRoute = findInitialRoute(routeName, initialRoutes);\n\n  state = createStateObject(\n    initialRoute,\n    routeName,\n    routeNames.length === 0,\n    params\n  );\n\n  if (routeNames.length > 0) {\n    let nestedState = state;\n\n    while ((routeName = routeNames.shift() as string)) {\n      initialRoute = findInitialRoute(routeName, initialRoutes);\n      nestedState.routes[nestedState.index || 0].state = createStateObject(\n        initialRoute,\n        routeName,\n        routeNames.length === 0,\n        params\n      );\n      if (routeNames.length > 0) {\n        nestedState = nestedState.routes[nestedState.index || 0]\n          .state as InitialState;\n      }\n    }\n  }\n\n  return state;\n}\n\nfunction findFocusedRoute(state: InitialState) {\n  let current: InitialState | undefined = state;\n\n  while (current?.routes[current.index || 0].state) {\n    // The query params apply to the deepest route\n    current = current.routes[current.index || 0].state;\n  }\n\n  const route = (current as PartialState<NavigationState>).routes[\n    current?.index || 0\n  ];\n\n  return route;\n}\n\nfunction parseQueryParams(\n  path: string,\n  parseConfig?: Record<string, (value: string) => any>\n) {\n  const query = path.split('?')[1];\n  const params = queryString.parse(query);\n\n  if (parseConfig) {\n    Object.keys(params).forEach((name) => {\n      if (parseConfig[name] && typeof params[name] === 'string') {\n        params[name] = parseConfig[name](params[name] as string);\n      }\n    });\n  }\n\n  return Object.keys(params).length ? params : undefined;\n}\n"]},"metadata":{},"sourceType":"module"}